generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                                    String         @id @default(uuid())
  email                                 String         @unique
  password                              String?
  name                                  String
  phoneNumber                           String
  country                               String
  role                                  Role
  status                                UserStatus     @default(ACTIVE)
  isVerified                            Boolean
  createdAt                             DateTime       @default(now())
  updatedAt                             DateTime       @updatedAt
  
  // OAuth fields
  googleId                              String?        @unique
  profilePicture                        String?
  authProvider                          AuthProvider   @default(EMAIL)
  Client                                Client?
  Freelancer                            Freelancer?
  Message_Message_receiverIdToUser      Message[]      @relation("Message_receiverIdToUser")
  Message_Message_senderIdToUser        Message[]      @relation("Message_senderIdToUser")
  Conversation_Conversation_user1IdToUser Conversation[] @relation("Conversation_user1IdToUser")
  Conversation_Conversation_user2IdToUser Conversation[] @relation("Conversation_user2IdToUser")

  wallet                                Wallet?
  
  // Media service relations
  verificationDocuments                 VerificationDocument[]
  jobAssets                             JobAsset[]
  chatAttachments                       ChatAttachment[]
  mediaFiles                            MediaFile[]
}

model Conversation {
  id            String    @id @default(uuid())
  user1Id       String    // First participant (always the smaller user ID)
  user2Id       String    // Second participant (always the larger user ID)
  lastMessageId String?   @unique // Reference to last message (unique for one-to-one relation)
  lastActivity  DateTime  @default(now())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relations
  user1         User      @relation("Conversation_user1IdToUser", fields: [user1Id], references: [id])
  user2         User      @relation("Conversation_user2IdToUser", fields: [user2Id], references: [id])
  messages      Message[]
  lastMessage   Message?  @relation("ConversationLastMessage", fields: [lastMessageId], references: [id])
  attachments   ChatAttachment[]
  
  // Ensure unique conversation between two users
  @@unique([user1Id, user2Id])
  @@index([user1Id, lastActivity])
  @@index([user2Id, lastActivity])
  @@index([lastActivity])
}

model Message {
  id                            String        @id @default(uuid())
  conversationId                String
  senderId                      String
  receiverId                    String
  content                       String
  timestamp                     DateTime      @default(now())
  readAt                        DateTime?     // Read receipt timestamp
  
  // Relations
  conversation                  Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender                        User          @relation("Message_senderIdToUser", fields: [senderId], references: [id])
  receiver                      User          @relation("Message_receiverIdToUser", fields: [receiverId], references: [id])
  ConversationAsLast            Conversation? @relation("ConversationLastMessage")
  attachments                   ChatAttachment[]

  // Indexes for efficient queries
  @@index([conversationId, timestamp])
  @@index([receiverId, readAt])
  @@index([senderId, timestamp])
}

model Otp {
  id          String    @id @default(cuid())
  email       String
  otp         String
  type        OtpType
  status      OtpStatus @default(PENDING)
  userId      String?
  attempts    Int       @default(0)
  metadata    Json?
  expiresAt   DateTime
  createdAt   DateTime  @default(now())
  verifiedAt  DateTime?
  lastAttempt DateTime?

  @@index([email, type, status])
  @@index([expiresAt])
}

model Client {
  id          String     @id @default(uuid())
  userId      String     @unique
  fullName    String
  companyName String?
  bio         String?
  website     String?
  location    String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  user        User       @relation(fields: [userId], references: [id])
  contracts   Contract[]
  jobs        Job[]
}

model Job {
  id          String     @id @default(uuid())
  clientId    String
  title       String
  description String
  budget      Float
  category    String
  status      JobStatus  @default(OPEN)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  contract    Contract?
  client      Client     @relation(fields: [clientId], references: [id])
  proposals   Proposal[]
  assets      JobAsset[]

  // Indexes for browse jobs performance
  @@index([status, createdAt(sort: Desc)])
  @@index([category, status])
  @@index([budget, status])
  @@index([status, budget, createdAt(sort: Desc)])
  @@index([category, budget, status])
}

model Contract {
  id           String         @id @default(uuid())
  clientId     String
  freelancerId String
  jobId        String         @unique
  status       ContractStatus @default(PENDING)
  startDate    DateTime
  endDate      DateTime?
  client       Client         @relation(fields: [clientId], references: [id])
  freelancer   Freelancer     @relation(fields: [freelancerId], references: [id])
  job          Job            @relation(fields: [jobId], references: [id])
  payments     Payment[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  review       Review?
}

model Freelancer {
  id              String          @id @default(uuid())
  userId          String          @unique
  fullName        String
  hourlyRate      Float?
  experienceLevel ExperienceLevel
  bio             String?
  profilePicture  String?
  isAvailable     Boolean         @default(true)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  contracts       Contract[]
  user            User            @relation(fields: [userId], references: [id])
  portfolioLinks  PortfolioLink[]
  proposals       Proposal[]
  reviews         Review[]
  skills          Skill[]         @relation("FreelancerSkills")
  withdrawals     Withdrawal[]    
}

model Skill {
  id          String       @id @default(uuid())
  name        String
  freelancers Freelancer[] @relation("FreelancerSkills")
}

model PortfolioLink {
  id           String     @id @default(uuid())
  title        String
  description  String?
  imageUrls    String[]
  githubUrl    String?
  liveUrl      String?
  freelancerId String
  freelancer   Freelancer @relation(fields: [freelancerId], references: [id])
}

model Proposal {
  id           String     @id @default(uuid())
  freelancerId String
  jobId        String
  coverLetter  String
  proposedRate Float
  createdAt    DateTime   @default(now())
  freelancer   Freelancer @relation(fields: [freelancerId], references: [id])
  job          Job        @relation(fields: [jobId], references: [id])
  status       ProposalStatus @default(PENDING)
}

enum ProposalStatus {
  PENDING
  INTERVIEWING
  ACCEPTED
  DECLINED
}

model Payment {
  id           String         @id @default(uuid())
  contractId   String         @unique
  amount       Int            @default(0)
  status       PaymentStatus  @default(PENDING)
  method       String?        // لاحقًا ممكن تكون STRIPE, PAYPAL, etc
  paidAt       DateTime?
  providerId   String?        // معرف الدفع من مزود الخدمة
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  contract     Contract       @relation(fields: [contractId], references: [id])
  
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

model Wallet {
  id        String   @id @default(uuid())
  userId    String   @unique
  balance   Int      @default(0) // stored in piasters (قرش) not float
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id])
  transactions WalletTransaction[]
}


model Withdrawal {
  id             String             @id @default(uuid())
  freelancerId   String
  amount         Float
  status         WithdrawalStatus   @default(PENDING)
  requestedAt    DateTime           @default(now())
  processedAt    DateTime?
  method         String?            // PAYPAL, BANK, etc
  notes          String?            // للمراجعة أو سبب الرفض

  freelancer     Freelancer         @relation(fields: [freelancerId], references: [id])

  @@index([status, requestedAt])
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

model WalletTransaction {
  id          String       @id @default(uuid())
  walletId    String
  amount      Int          // بالقرش
  type        TransactionType
  relatedId   String?      // ممكن تكون Payment ID، Withdrawal ID، إلخ
  metadata    Json?        // لو حبيت تخزن حاجة إضافية
  createdAt   DateTime     @default(now())

  wallet      Wallet       @relation(fields: [walletId], references: [id])

  @@index([walletId, createdAt])
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  HOLD
  RELEASE
  ADJUSTMENT
}


model Review {
  id           String     @id @default(uuid())
  contractId   String     @unique
  rating       Int
  feedback     String?
  createdAt    DateTime   @default(now())
  freelancerId String
  contract     Contract   @relation(fields: [contractId], references: [id])
  freelancer   Freelancer @relation(fields: [freelancerId], references: [id])
}

enum Role {
  CLIENT
  FREELANCER
  ADMIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  BANNED
}

enum OtpType {
  PASSWORD_RESET
  EMAIL_VERIFICATION
  TWO_FACTOR_AUTH
  ACCOUNT_VERIFICATION
}

enum OtpStatus {
  PENDING
  VERIFIED
  EXPIRED
  USED
}

enum JobStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELED
}

enum ContractStatus {
  PENDING
  ACTIVE
  COMPLETED
  CANCELED
}

enum ExperienceLevel {
  JUNIOR
  MID
  SENIOR
}

enum AuthProvider {
  EMAIL
  GOOGLE
}

// Media Service Models
model VerificationDocument {
  id            String                 @id @default(uuid())
  userId        String
  docType       VerificationDocType
  fileName      String                 // R2 object key
  originalName  String
  fileType      String
  fileSize      Int
  status        VerificationStatus     @default(PENDING)
  uploadedAt    DateTime               @default(now())
  reviewedAt    DateTime?
  reviewedBy    String?                // Admin user ID
  rejectionReason String?             // Reason for rejection
  adminNotes    String?                // Additional notes from admin
  metadata      Json?                  // Additional metadata
  createdAt     DateTime               @default(now())
  updatedAt     DateTime               @updatedAt

  user          User                   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, docType]) // Each user can have only one doc per type
  @@index([userId, status])
  @@index([status, uploadedAt])
  @@index([status, reviewedAt])
}

model JobAsset {
  id           String    @id @default(uuid())
  userId       String    // Owner of the file
  jobId        String?   // Can be null for draft jobs
  fileName     String    // R2 object key
  originalName String
  fileType     String
  fileSize     Int
  category     String?   // e.g., 'requirements', 'reference', 'mockup'
  isPublic     Boolean   @default(false)
  url          String?   // Public URL if isPublic is true
  uploadedAt   DateTime  @default(now())
  metadata     Json?     // Additional metadata
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  job          Job?      @relation(fields: [jobId], references: [id], onDelete: SetNull)

  @@index([userId, jobId])
  @@index([jobId, isPublic])
  @@index([uploadedAt])
}

model ChatAttachment {
  id           String    @id @default(uuid())
  userId       String    // Uploader
  chatId       String    // Reference to conversation
  messageId    String?   // Reference to specific message
  fileName     String    // R2 object key
  originalName String
  fileType     String
  fileSize     Int
  url          String    // Internal URL for serving
  uploadedAt   DateTime  @default(now())
  metadata     Json?     // Additional metadata
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation Conversation @relation(fields: [chatId], references: [id], onDelete: Cascade)
  message      Message?     @relation(fields: [messageId], references: [id], onDelete: SetNull)

  @@index([chatId, uploadedAt])
  @@index([userId, uploadedAt])
  @@index([messageId])
}

model MediaFile {
  id           String         @id @default(uuid())
  userId       String         // Owner of the file
  fileName     String         // R2 object key
  originalName String
  fileType     String
  fileSize     Int
  uploadType   MediaUploadType
  category     String?
  isPublic     Boolean        @default(false)
  url          String?        // Public URL if isPublic is true
  uploadedAt   DateTime       @default(now())
  metadata     Json?          // Additional metadata
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, uploadType])
  @@index([uploadType, isPublic])
  @@index([uploadedAt])
}

// Enums for Media Service
enum VerificationDocType {
  FRONT  // Front of ID
  BACK   // Back of ID
  SELFIE // Selfie with ID
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum MediaUploadType {
  VERIFICATION
  JOB
  CHAT
  PROFILE
  OTHER
}
