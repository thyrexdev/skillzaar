generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String     @id @default(uuid())
  email       String     @unique
  password    String?
  name        String
  phoneNumber String
  country     String
  role        Role
  status      UserStatus @default(ACTIVE)
  isVerified  Boolean
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // OAuth fields
  googleId                                String?        @unique
  profilePicture                          String?
  authProvider                            AuthProvider   @default(EMAIL)
  Client                                  Client?
  Freelancer                              Freelancer?
  Message_Message_receiverIdToUser        Message[]      @relation("Message_receiverIdToUser")
  Message_Message_senderIdToUser          Message[]      @relation("Message_senderIdToUser")
  Conversation_Conversation_user1IdToUser Conversation[] @relation("Conversation_user1IdToUser")
  Conversation_Conversation_user2IdToUser Conversation[] @relation("Conversation_user2IdToUser")

  wallet Wallet?

  // Media service relations
  verificationDocuments VerificationDocument[]
  jobAssets             JobAsset[]
  chatAttachments       ChatAttachment[]
  mediaFiles            MediaFile[]
}

model Conversation {
  id            String   @id @default(uuid())
  user1Id       String // First participant (always the smaller user ID)
  user2Id       String // Second participant (always the larger user ID)
  lastMessageId String?  @unique // Reference to last message (unique for one-to-one relation)
  lastActivity  DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user1       User             @relation("Conversation_user1IdToUser", fields: [user1Id], references: [id])
  user2       User             @relation("Conversation_user2IdToUser", fields: [user2Id], references: [id])
  messages    Message[]
  lastMessage Message?         @relation("ConversationLastMessage", fields: [lastMessageId], references: [id])
  attachments ChatAttachment[]

  // Ensure unique conversation between two users
  @@unique([user1Id, user2Id])
  @@index([user1Id, lastActivity])
  @@index([user2Id, lastActivity])
  @@index([lastActivity])
}

model Message {
  id             String    @id @default(uuid())
  conversationId String
  senderId       String
  receiverId     String
  content        String
  timestamp      DateTime  @default(now())
  readAt         DateTime? // Read receipt timestamp

  // Relations
  conversation       Conversation     @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender             User             @relation("Message_senderIdToUser", fields: [senderId], references: [id])
  receiver           User             @relation("Message_receiverIdToUser", fields: [receiverId], references: [id])
  ConversationAsLast Conversation?    @relation("ConversationLastMessage")
  attachments        ChatAttachment[]

  // Indexes for efficient queries
  @@index([conversationId, timestamp])
  @@index([receiverId, readAt])
  @@index([senderId, timestamp])
}

model Otp {
  id          String    @id @default(cuid())
  email       String
  otp         String
  type        OtpType
  status      OtpStatus @default(PENDING)
  userId      String?
  attempts    Int       @default(0)
  metadata    Json?
  expiresAt   DateTime
  createdAt   DateTime  @default(now())
  verifiedAt  DateTime?
  lastAttempt DateTime?

  @@index([email, type, status])
  @@index([expiresAt])
}

model Client {
  id          String     @id @default(uuid())
  userId      String     @unique
  fullName    String
  companyName String?
  bio         String?
  website     String?
  location    String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  user        User       @relation(fields: [userId], references: [id])
  contracts   Contract[]
  jobs        Job[]
}

model Job {
  id          String     @id @default(uuid())
  clientId    String
  title       String
  description String
  budget      Float
  category    String
  status      JobStatus  @default(OPEN)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  contract    Contract?
  client      Client     @relation(fields: [clientId], references: [id])
  proposals   Proposal[]
  assets      JobAsset[]

  // Indexes for browse jobs performance
  @@index([status, createdAt(sort: Desc)])
  @@index([category, status])
  @@index([budget, status])
  @@index([status, budget, createdAt(sort: Desc)])
  @@index([category, budget, status])
}

model Contract {
  id           String         @id @default(uuid())
  clientId     String
  freelancerId String
  jobId        String         @unique
  status       ContractStatus @default(PENDING)
  startDate    DateTime
  endDate      DateTime?
  client       Client         @relation(fields: [clientId], references: [id])
  freelancer   Freelancer     @relation(fields: [freelancerId], references: [id])
  job          Job            @relation(fields: [jobId], references: [id])
  payments     Payment[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  review       Review?
}

model Freelancer {
  id              String          @id @default(uuid())
  userId          String          @unique
  fullName        String
  hourlyRate      Float?
  experienceLevel ExperienceLevel
  bio             String?
  profilePicture  String?
  isAvailable     Boolean         @default(true)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  contracts       Contract[]
  user            User            @relation(fields: [userId], references: [id])
  portfolioLinks  PortfolioLink[]
  proposals       Proposal[]
  reviews         Review[]
  skills          Skill[]         @relation("FreelancerSkills")
  withdrawals     Withdrawal[]
}

model Skill {
  id          String       @id @default(uuid())
  name        String
  freelancers Freelancer[] @relation("FreelancerSkills")
}

model PortfolioLink {
  id           String     @id @default(uuid())
  title        String
  description  String?
  imageUrls    String[]
  githubUrl    String?
  liveUrl      String?
  freelancerId String
  freelancer   Freelancer @relation(fields: [freelancerId], references: [id])
}

model Proposal {
  id           String         @id @default(uuid())
  freelancerId String
  jobId        String
  coverLetter  String
  proposedRate Float
  createdAt    DateTime       @default(now())
  freelancer   Freelancer     @relation(fields: [freelancerId], references: [id])
  job          Job            @relation(fields: [jobId], references: [id])
  status       ProposalStatus @default(PENDING)
}

enum ProposalStatus {
  PENDING
  INTERVIEWING
  ACCEPTED
  DECLINED
}

model Payment {
  id         String        @id @default(uuid())
  contractId String        @unique
  amount     Int           @default(0)
  status     PaymentStatus @default(PENDING)
  method     String? // لاحقًا ممكن تكون STRIPE, PAYPAL, etc
  paidAt     DateTime?
  providerId String? // معرف الدفع من مزود الخدمة
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  contract Contract @relation(fields: [contractId], references: [id])
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

model Wallet {
  id        String   @id @default(uuid())
  userId    String   @unique
  balance   Int      @default(0) // stored in piasters (قرش) not float
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  user         User                @relation(fields: [userId], references: [id])
  transactions WalletTransaction[]
}

model Withdrawal {
  id           String           @id @default(uuid())
  freelancerId String
  amount       Float
  status       WithdrawalStatus @default(PENDING)
  requestedAt  DateTime         @default(now())
  processedAt  DateTime?
  method       String? // PAYPAL, BANK, etc
  notes        String? // للمراجعة أو سبب الرفض

  freelancer Freelancer @relation(fields: [freelancerId], references: [id])

  @@index([status, requestedAt])
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

model WalletTransaction {
  id        String          @id @default(uuid())
  walletId  String
  amount    Int // بالقرش
  type      TransactionType
  relatedId String? // ممكن تكون Payment ID، Withdrawal ID، إلخ
  metadata  Json? // لو حبيت تخزن حاجة إضافية
  createdAt DateTime        @default(now())

  wallet Wallet @relation(fields: [walletId], references: [id])

  @@index([walletId, createdAt])
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  HOLD
  RELEASE
  ADJUSTMENT
}

model Review {
  id           String     @id @default(uuid())
  contractId   String     @unique
  rating       Int
  feedback     String?
  createdAt    DateTime   @default(now())
  freelancerId String
  contract     Contract   @relation(fields: [contractId], references: [id])
  freelancer   Freelancer @relation(fields: [freelancerId], references: [id])
}

enum Role {
  CLIENT
  FREELANCER
  ADMIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  BANNED
}

enum OtpType {
  PASSWORD_RESET
  EMAIL_VERIFICATION
  TWO_FACTOR_AUTH
  ACCOUNT_VERIFICATION
}

enum OtpStatus {
  PENDING
  VERIFIED
  EXPIRED
  USED
}

enum JobStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELED
}

enum ContractStatus {
  PENDING
  ACTIVE
  COMPLETED
  CANCELED
}

enum ExperienceLevel {
  JUNIOR
  MID
  SENIOR
}

enum AuthProvider {
  EMAIL
  GOOGLE
}

// Media Service Models
model VerificationDocument {
  id              String              @id @default(uuid())
  userId          String
  docType         VerificationDocType
  fileName        String // R2 object key
  originalName    String
  fileType        String
  fileSize        Int
  status          VerificationStatus  @default(PENDING)
  uploadedAt      DateTime            @default(now())
  reviewedAt      DateTime?
  reviewedBy      String? // Admin user ID
  rejectionReason String? // Reason for rejection
  adminNotes      String? // Additional notes from admin
  metadata        Json? // Additional metadata
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, docType]) // Each user can have only one doc per type
  @@index([userId, status])
  @@index([status, uploadedAt])
  @@index([status, reviewedAt])
}

model JobAsset {
  id           String   @id @default(uuid())
  userId       String // Owner of the file
  jobId        String? // Can be null for draft jobs
  fileName     String // R2 object key
  originalName String
  fileType     String
  fileSize     Int
  category     String? // e.g., 'requirements', 'reference', 'mockup'
  isPublic     Boolean  @default(false)
  url          String? // Public URL if isPublic is true
  uploadedAt   DateTime @default(now())
  metadata     Json? // Additional metadata
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  job  Job? @relation(fields: [jobId], references: [id], onDelete: SetNull)

  @@index([userId, jobId])
  @@index([jobId, isPublic])
  @@index([uploadedAt])
}

model ChatAttachment {
  id           String   @id @default(uuid())
  userId       String // Uploader
  chatId       String // Reference to conversation
  messageId    String? // Reference to specific message
  fileName     String // R2 object key
  originalName String
  fileType     String
  fileSize     Int
  url          String // Internal URL for serving
  uploadedAt   DateTime @default(now())
  metadata     Json? // Additional metadata
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation Conversation @relation(fields: [chatId], references: [id], onDelete: Cascade)
  message      Message?     @relation(fields: [messageId], references: [id], onDelete: SetNull)

  @@index([chatId, uploadedAt])
  @@index([userId, uploadedAt])
  @@index([messageId])
}

model MediaFile {
  id           String          @id @default(uuid())
  userId       String // Owner of the file
  fileName     String // R2 object key
  originalName String
  fileType     String
  fileSize     Int
  uploadType   MediaUploadType
  category     String?
  isPublic     Boolean         @default(false)
  url          String? // Public URL if isPublic is true
  uploadedAt   DateTime        @default(now())
  metadata     Json? // Additional metadata
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, uploadType])
  @@index([uploadType, isPublic])
  @@index([uploadedAt])
}

// Enums for Media Service
enum VerificationDocType {
  FRONT // Front of ID
  BACK // Back of ID
  SELFIE // Selfie with ID
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum MediaUploadType {
  VERIFICATION
  JOB
  CHAT
  PROFILE
  OTHER
}
